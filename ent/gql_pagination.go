// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/entkit/entkit-demo/ent/company"
	"github.com/entkit/entkit-demo/ent/country"
	"github.com/entkit/entkit-demo/ent/email"
	"github.com/entkit/entkit-demo/ent/image"
	"github.com/entkit/entkit-demo/ent/location"
	"github.com/entkit/entkit-demo/ent/phone"
	"github.com/entkit/entkit-demo/ent/product"
	"github.com/entkit/entkit-demo/ent/vendor"
	"github.com/entkit/entkit-demo/ent/warehouse"
	"github.com/entkit/entkit-demo/ent/website"
	"github.com/google/uuid"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[uuid.UUID]
	PageInfo       = entgql.PageInfo[uuid.UUID]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// CompanyEdge is the edge representation of Company.
type CompanyEdge struct {
	Node   *Company `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// CompanyConnection is the connection containing edges to Company.
type CompanyConnection struct {
	Edges      []*CompanyEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *CompanyConnection) build(nodes []*Company, pager *companyPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Company
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Company {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Company {
			return nodes[i]
		}
	}
	c.Edges = make([]*CompanyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CompanyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CompanyPaginateOption enables pagination customization.
type CompanyPaginateOption func(*companyPager) error

// WithCompanyOrder configures pagination ordering.
func WithCompanyOrder(order *CompanyOrder) CompanyPaginateOption {
	if order == nil {
		order = DefaultCompanyOrder
	}
	o := *order
	return func(pager *companyPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCompanyOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCompanyFilter configures pagination filter.
func WithCompanyFilter(filter func(*CompanyQuery) (*CompanyQuery, error)) CompanyPaginateOption {
	return func(pager *companyPager) error {
		if filter == nil {
			return errors.New("CompanyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type companyPager struct {
	reverse bool
	order   *CompanyOrder
	filter  func(*CompanyQuery) (*CompanyQuery, error)
}

func newCompanyPager(opts []CompanyPaginateOption, reverse bool) (*companyPager, error) {
	pager := &companyPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCompanyOrder
	}
	return pager, nil
}

func (p *companyPager) applyFilter(query *CompanyQuery) (*CompanyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *companyPager) toCursor(c *Company) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *companyPager) applyCursors(query *CompanyQuery, after, before *Cursor) (*CompanyQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCompanyOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *companyPager) applyOrder(query *CompanyQuery) *CompanyQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCompanyOrder.Field {
		query = query.Order(DefaultCompanyOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *companyPager) orderExpr(query *CompanyQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCompanyOrder.Field {
			b.Comma().Ident(DefaultCompanyOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Company.
func (c *CompanyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CompanyPaginateOption,
) (*CompanyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCompanyPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CompanyConnection{Edges: []*CompanyEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = c.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	c = pager.applyOrder(c)
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CompanyOrderFieldID orders Company by id.
	CompanyOrderFieldID = &CompanyOrderField{
		Value: func(c *Company) (ent.Value, error) {
			return c.ID, nil
		},
		column: company.FieldID,
		toTerm: company.ByID,
		toCursor: func(c *Company) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.ID,
			}
		},
	}
	// CompanyOrderFieldName orders Company by name.
	CompanyOrderFieldName = &CompanyOrderField{
		Value: func(c *Company) (ent.Value, error) {
			return c.Name, nil
		},
		column: company.FieldName,
		toTerm: company.ByName,
		toCursor: func(c *Company) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Name,
			}
		},
	}
	// CompanyOrderFieldDescription orders Company by description.
	CompanyOrderFieldDescription = &CompanyOrderField{
		Value: func(c *Company) (ent.Value, error) {
			return c.Description, nil
		},
		column: company.FieldDescription,
		toTerm: company.ByDescription,
		toCursor: func(c *Company) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Description,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CompanyOrderField) String() string {
	var str string
	switch f.column {
	case CompanyOrderFieldID.column:
		str = "ID"
	case CompanyOrderFieldName.column:
		str = "NAME"
	case CompanyOrderFieldDescription.column:
		str = "DESCRIPTION"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CompanyOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CompanyOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CompanyOrderField %T must be a string", v)
	}
	switch str {
	case "ID":
		*f = *CompanyOrderFieldID
	case "NAME":
		*f = *CompanyOrderFieldName
	case "DESCRIPTION":
		*f = *CompanyOrderFieldDescription
	default:
		return fmt.Errorf("%s is not a valid CompanyOrderField", str)
	}
	return nil
}

// CompanyOrderField defines the ordering field of Company.
type CompanyOrderField struct {
	// Value extracts the ordering value from the given Company.
	Value    func(*Company) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) company.OrderOption
	toCursor func(*Company) Cursor
}

// CompanyOrder defines the ordering of Company.
type CompanyOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *CompanyOrderField `json:"field"`
}

// DefaultCompanyOrder is the default ordering of Company.
var DefaultCompanyOrder = &CompanyOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CompanyOrderField{
		Value: func(c *Company) (ent.Value, error) {
			return c.ID, nil
		},
		column: company.FieldID,
		toTerm: company.ByID,
		toCursor: func(c *Company) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Company into CompanyEdge.
func (c *Company) ToEdge(order *CompanyOrder) *CompanyEdge {
	if order == nil {
		order = DefaultCompanyOrder
	}
	return &CompanyEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CountryEdge is the edge representation of Country.
type CountryEdge struct {
	Node   *Country `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// CountryConnection is the connection containing edges to Country.
type CountryConnection struct {
	Edges      []*CountryEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *CountryConnection) build(nodes []*Country, pager *countryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Country
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Country {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Country {
			return nodes[i]
		}
	}
	c.Edges = make([]*CountryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CountryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CountryPaginateOption enables pagination customization.
type CountryPaginateOption func(*countryPager) error

// WithCountryOrder configures pagination ordering.
func WithCountryOrder(order *CountryOrder) CountryPaginateOption {
	if order == nil {
		order = DefaultCountryOrder
	}
	o := *order
	return func(pager *countryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCountryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCountryFilter configures pagination filter.
func WithCountryFilter(filter func(*CountryQuery) (*CountryQuery, error)) CountryPaginateOption {
	return func(pager *countryPager) error {
		if filter == nil {
			return errors.New("CountryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type countryPager struct {
	reverse bool
	order   *CountryOrder
	filter  func(*CountryQuery) (*CountryQuery, error)
}

func newCountryPager(opts []CountryPaginateOption, reverse bool) (*countryPager, error) {
	pager := &countryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCountryOrder
	}
	return pager, nil
}

func (p *countryPager) applyFilter(query *CountryQuery) (*CountryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *countryPager) toCursor(c *Country) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *countryPager) applyCursors(query *CountryQuery, after, before *Cursor) (*CountryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCountryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *countryPager) applyOrder(query *CountryQuery) *CountryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCountryOrder.Field {
		query = query.Order(DefaultCountryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *countryPager) orderExpr(query *CountryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCountryOrder.Field {
			b.Comma().Ident(DefaultCountryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Country.
func (c *CountryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CountryPaginateOption,
) (*CountryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCountryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CountryConnection{Edges: []*CountryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = c.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	c = pager.applyOrder(c)
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CountryOrderFieldID orders Country by id.
	CountryOrderFieldID = &CountryOrderField{
		Value: func(c *Country) (ent.Value, error) {
			return c.ID, nil
		},
		column: country.FieldID,
		toTerm: country.ByID,
		toCursor: func(c *Country) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.ID,
			}
		},
	}
	// CountryOrderFieldName orders Country by name.
	CountryOrderFieldName = &CountryOrderField{
		Value: func(c *Country) (ent.Value, error) {
			return c.Name, nil
		},
		column: country.FieldName,
		toTerm: country.ByName,
		toCursor: func(c *Country) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Name,
			}
		},
	}
	// CountryOrderFieldCode orders Country by code.
	CountryOrderFieldCode = &CountryOrderField{
		Value: func(c *Country) (ent.Value, error) {
			return c.Code, nil
		},
		column: country.FieldCode,
		toTerm: country.ByCode,
		toCursor: func(c *Country) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Code,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CountryOrderField) String() string {
	var str string
	switch f.column {
	case CountryOrderFieldID.column:
		str = "ID"
	case CountryOrderFieldName.column:
		str = "NAME"
	case CountryOrderFieldCode.column:
		str = "CODE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CountryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CountryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CountryOrderField %T must be a string", v)
	}
	switch str {
	case "ID":
		*f = *CountryOrderFieldID
	case "NAME":
		*f = *CountryOrderFieldName
	case "CODE":
		*f = *CountryOrderFieldCode
	default:
		return fmt.Errorf("%s is not a valid CountryOrderField", str)
	}
	return nil
}

// CountryOrderField defines the ordering field of Country.
type CountryOrderField struct {
	// Value extracts the ordering value from the given Country.
	Value    func(*Country) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) country.OrderOption
	toCursor func(*Country) Cursor
}

// CountryOrder defines the ordering of Country.
type CountryOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *CountryOrderField `json:"field"`
}

// DefaultCountryOrder is the default ordering of Country.
var DefaultCountryOrder = &CountryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CountryOrderField{
		Value: func(c *Country) (ent.Value, error) {
			return c.ID, nil
		},
		column: country.FieldID,
		toTerm: country.ByID,
		toCursor: func(c *Country) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Country into CountryEdge.
func (c *Country) ToEdge(order *CountryOrder) *CountryEdge {
	if order == nil {
		order = DefaultCountryOrder
	}
	return &CountryEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// EmailEdge is the edge representation of Email.
type EmailEdge struct {
	Node   *Email `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// EmailConnection is the connection containing edges to Email.
type EmailConnection struct {
	Edges      []*EmailEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *EmailConnection) build(nodes []*Email, pager *emailPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Email
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Email {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Email {
			return nodes[i]
		}
	}
	c.Edges = make([]*EmailEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EmailEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EmailPaginateOption enables pagination customization.
type EmailPaginateOption func(*emailPager) error

// WithEmailOrder configures pagination ordering.
func WithEmailOrder(order *EmailOrder) EmailPaginateOption {
	if order == nil {
		order = DefaultEmailOrder
	}
	o := *order
	return func(pager *emailPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEmailOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEmailFilter configures pagination filter.
func WithEmailFilter(filter func(*EmailQuery) (*EmailQuery, error)) EmailPaginateOption {
	return func(pager *emailPager) error {
		if filter == nil {
			return errors.New("EmailQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type emailPager struct {
	reverse bool
	order   *EmailOrder
	filter  func(*EmailQuery) (*EmailQuery, error)
}

func newEmailPager(opts []EmailPaginateOption, reverse bool) (*emailPager, error) {
	pager := &emailPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEmailOrder
	}
	return pager, nil
}

func (p *emailPager) applyFilter(query *EmailQuery) (*EmailQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *emailPager) toCursor(e *Email) Cursor {
	return p.order.Field.toCursor(e)
}

func (p *emailPager) applyCursors(query *EmailQuery, after, before *Cursor) (*EmailQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEmailOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *emailPager) applyOrder(query *EmailQuery) *EmailQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEmailOrder.Field {
		query = query.Order(DefaultEmailOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *emailPager) orderExpr(query *EmailQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEmailOrder.Field {
			b.Comma().Ident(DefaultEmailOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Email.
func (e *EmailQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EmailPaginateOption,
) (*EmailConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEmailPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}
	conn := &EmailConnection{Edges: []*EmailEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = e.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if e, err = pager.applyCursors(e, after, before); err != nil {
		return nil, err
	}
	e = pager.applyOrder(e)
	if limit := paginateLimit(first, last); limit != 0 {
		e.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := e.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := e.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EmailOrderFieldID orders Email by id.
	EmailOrderFieldID = &EmailOrderField{
		Value: func(e *Email) (ent.Value, error) {
			return e.ID, nil
		},
		column: email.FieldID,
		toTerm: email.ByID,
		toCursor: func(e *Email) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.ID,
			}
		},
	}
	// EmailOrderFieldTitle orders Email by title.
	EmailOrderFieldTitle = &EmailOrderField{
		Value: func(e *Email) (ent.Value, error) {
			return e.Title, nil
		},
		column: email.FieldTitle,
		toTerm: email.ByTitle,
		toCursor: func(e *Email) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.Title,
			}
		},
	}
	// EmailOrderFieldDescription orders Email by description.
	EmailOrderFieldDescription = &EmailOrderField{
		Value: func(e *Email) (ent.Value, error) {
			return e.Description, nil
		},
		column: email.FieldDescription,
		toTerm: email.ByDescription,
		toCursor: func(e *Email) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.Description,
			}
		},
	}
	// EmailOrderFieldAddress orders Email by address.
	EmailOrderFieldAddress = &EmailOrderField{
		Value: func(e *Email) (ent.Value, error) {
			return e.Address, nil
		},
		column: email.FieldAddress,
		toTerm: email.ByAddress,
		toCursor: func(e *Email) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.Address,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EmailOrderField) String() string {
	var str string
	switch f.column {
	case EmailOrderFieldID.column:
		str = "ID"
	case EmailOrderFieldTitle.column:
		str = "TITLE"
	case EmailOrderFieldDescription.column:
		str = "DESCRIPTION"
	case EmailOrderFieldAddress.column:
		str = "ADDRESS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EmailOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EmailOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EmailOrderField %T must be a string", v)
	}
	switch str {
	case "ID":
		*f = *EmailOrderFieldID
	case "TITLE":
		*f = *EmailOrderFieldTitle
	case "DESCRIPTION":
		*f = *EmailOrderFieldDescription
	case "ADDRESS":
		*f = *EmailOrderFieldAddress
	default:
		return fmt.Errorf("%s is not a valid EmailOrderField", str)
	}
	return nil
}

// EmailOrderField defines the ordering field of Email.
type EmailOrderField struct {
	// Value extracts the ordering value from the given Email.
	Value    func(*Email) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) email.OrderOption
	toCursor func(*Email) Cursor
}

// EmailOrder defines the ordering of Email.
type EmailOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *EmailOrderField `json:"field"`
}

// DefaultEmailOrder is the default ordering of Email.
var DefaultEmailOrder = &EmailOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EmailOrderField{
		Value: func(e *Email) (ent.Value, error) {
			return e.ID, nil
		},
		column: email.FieldID,
		toTerm: email.ByID,
		toCursor: func(e *Email) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Email into EmailEdge.
func (e *Email) ToEdge(order *EmailOrder) *EmailEdge {
	if order == nil {
		order = DefaultEmailOrder
	}
	return &EmailEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// ImageEdge is the edge representation of Image.
type ImageEdge struct {
	Node   *Image `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// ImageConnection is the connection containing edges to Image.
type ImageConnection struct {
	Edges      []*ImageEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *ImageConnection) build(nodes []*Image, pager *imagePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Image
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Image {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Image {
			return nodes[i]
		}
	}
	c.Edges = make([]*ImageEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ImageEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ImagePaginateOption enables pagination customization.
type ImagePaginateOption func(*imagePager) error

// WithImageOrder configures pagination ordering.
func WithImageOrder(order *ImageOrder) ImagePaginateOption {
	if order == nil {
		order = DefaultImageOrder
	}
	o := *order
	return func(pager *imagePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultImageOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithImageFilter configures pagination filter.
func WithImageFilter(filter func(*ImageQuery) (*ImageQuery, error)) ImagePaginateOption {
	return func(pager *imagePager) error {
		if filter == nil {
			return errors.New("ImageQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type imagePager struct {
	reverse bool
	order   *ImageOrder
	filter  func(*ImageQuery) (*ImageQuery, error)
}

func newImagePager(opts []ImagePaginateOption, reverse bool) (*imagePager, error) {
	pager := &imagePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultImageOrder
	}
	return pager, nil
}

func (p *imagePager) applyFilter(query *ImageQuery) (*ImageQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *imagePager) toCursor(i *Image) Cursor {
	return p.order.Field.toCursor(i)
}

func (p *imagePager) applyCursors(query *ImageQuery, after, before *Cursor) (*ImageQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultImageOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *imagePager) applyOrder(query *ImageQuery) *ImageQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultImageOrder.Field {
		query = query.Order(DefaultImageOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *imagePager) orderExpr(query *ImageQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultImageOrder.Field {
			b.Comma().Ident(DefaultImageOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Image.
func (i *ImageQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ImagePaginateOption,
) (*ImageConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newImagePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if i, err = pager.applyFilter(i); err != nil {
		return nil, err
	}
	conn := &ImageConnection{Edges: []*ImageEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = i.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if i, err = pager.applyCursors(i, after, before); err != nil {
		return nil, err
	}
	i = pager.applyOrder(i)
	if limit := paginateLimit(first, last); limit != 0 {
		i.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := i.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := i.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ImageOrderFieldID orders Image by id.
	ImageOrderFieldID = &ImageOrderField{
		Value: func(i *Image) (ent.Value, error) {
			return i.ID, nil
		},
		column: image.FieldID,
		toTerm: image.ByID,
		toCursor: func(i *Image) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.ID,
			}
		},
	}
	// ImageOrderFieldTitle orders Image by title.
	ImageOrderFieldTitle = &ImageOrderField{
		Value: func(i *Image) (ent.Value, error) {
			return i.Title, nil
		},
		column: image.FieldTitle,
		toTerm: image.ByTitle,
		toCursor: func(i *Image) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.Title,
			}
		},
	}
	// ImageOrderFieldOriginalURL orders Image by original_url.
	ImageOrderFieldOriginalURL = &ImageOrderField{
		Value: func(i *Image) (ent.Value, error) {
			return i.OriginalURL, nil
		},
		column: image.FieldOriginalURL,
		toTerm: image.ByOriginalURL,
		toCursor: func(i *Image) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.OriginalURL,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ImageOrderField) String() string {
	var str string
	switch f.column {
	case ImageOrderFieldID.column:
		str = "ID"
	case ImageOrderFieldTitle.column:
		str = "TITLE"
	case ImageOrderFieldOriginalURL.column:
		str = "ORIGINAL_URL"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ImageOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ImageOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ImageOrderField %T must be a string", v)
	}
	switch str {
	case "ID":
		*f = *ImageOrderFieldID
	case "TITLE":
		*f = *ImageOrderFieldTitle
	case "ORIGINAL_URL":
		*f = *ImageOrderFieldOriginalURL
	default:
		return fmt.Errorf("%s is not a valid ImageOrderField", str)
	}
	return nil
}

// ImageOrderField defines the ordering field of Image.
type ImageOrderField struct {
	// Value extracts the ordering value from the given Image.
	Value    func(*Image) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) image.OrderOption
	toCursor func(*Image) Cursor
}

// ImageOrder defines the ordering of Image.
type ImageOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *ImageOrderField `json:"field"`
}

// DefaultImageOrder is the default ordering of Image.
var DefaultImageOrder = &ImageOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ImageOrderField{
		Value: func(i *Image) (ent.Value, error) {
			return i.ID, nil
		},
		column: image.FieldID,
		toTerm: image.ByID,
		toCursor: func(i *Image) Cursor {
			return Cursor{ID: i.ID}
		},
	},
}

// ToEdge converts Image into ImageEdge.
func (i *Image) ToEdge(order *ImageOrder) *ImageEdge {
	if order == nil {
		order = DefaultImageOrder
	}
	return &ImageEdge{
		Node:   i,
		Cursor: order.Field.toCursor(i),
	}
}

// LocationEdge is the edge representation of Location.
type LocationEdge struct {
	Node   *Location `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// LocationConnection is the connection containing edges to Location.
type LocationConnection struct {
	Edges      []*LocationEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *LocationConnection) build(nodes []*Location, pager *locationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Location
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Location {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Location {
			return nodes[i]
		}
	}
	c.Edges = make([]*LocationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &LocationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// LocationPaginateOption enables pagination customization.
type LocationPaginateOption func(*locationPager) error

// WithLocationOrder configures pagination ordering.
func WithLocationOrder(order *LocationOrder) LocationPaginateOption {
	if order == nil {
		order = DefaultLocationOrder
	}
	o := *order
	return func(pager *locationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultLocationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithLocationFilter configures pagination filter.
func WithLocationFilter(filter func(*LocationQuery) (*LocationQuery, error)) LocationPaginateOption {
	return func(pager *locationPager) error {
		if filter == nil {
			return errors.New("LocationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type locationPager struct {
	reverse bool
	order   *LocationOrder
	filter  func(*LocationQuery) (*LocationQuery, error)
}

func newLocationPager(opts []LocationPaginateOption, reverse bool) (*locationPager, error) {
	pager := &locationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultLocationOrder
	}
	return pager, nil
}

func (p *locationPager) applyFilter(query *LocationQuery) (*LocationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *locationPager) toCursor(l *Location) Cursor {
	return p.order.Field.toCursor(l)
}

func (p *locationPager) applyCursors(query *LocationQuery, after, before *Cursor) (*LocationQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultLocationOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *locationPager) applyOrder(query *LocationQuery) *LocationQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultLocationOrder.Field {
		query = query.Order(DefaultLocationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *locationPager) orderExpr(query *LocationQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultLocationOrder.Field {
			b.Comma().Ident(DefaultLocationOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Location.
func (l *LocationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...LocationPaginateOption,
) (*LocationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLocationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if l, err = pager.applyFilter(l); err != nil {
		return nil, err
	}
	conn := &LocationConnection{Edges: []*LocationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = l.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if l, err = pager.applyCursors(l, after, before); err != nil {
		return nil, err
	}
	l = pager.applyOrder(l)
	if limit := paginateLimit(first, last); limit != 0 {
		l.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := l.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := l.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// LocationOrderFieldID orders Location by id.
	LocationOrderFieldID = &LocationOrderField{
		Value: func(l *Location) (ent.Value, error) {
			return l.ID, nil
		},
		column: location.FieldID,
		toTerm: location.ByID,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.ID,
			}
		},
	}
	// LocationOrderFieldTitle orders Location by title.
	LocationOrderFieldTitle = &LocationOrderField{
		Value: func(l *Location) (ent.Value, error) {
			return l.Title, nil
		},
		column: location.FieldTitle,
		toTerm: location.ByTitle,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.Title,
			}
		},
	}
	// LocationOrderFieldDescription orders Location by description.
	LocationOrderFieldDescription = &LocationOrderField{
		Value: func(l *Location) (ent.Value, error) {
			return l.Description, nil
		},
		column: location.FieldDescription,
		toTerm: location.ByDescription,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.Description,
			}
		},
	}
	// LocationOrderFieldLatitude orders Location by latitude.
	LocationOrderFieldLatitude = &LocationOrderField{
		Value: func(l *Location) (ent.Value, error) {
			return l.Latitude, nil
		},
		column: location.FieldLatitude,
		toTerm: location.ByLatitude,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.Latitude,
			}
		},
	}
	// LocationOrderFieldLongitude orders Location by longitude.
	LocationOrderFieldLongitude = &LocationOrderField{
		Value: func(l *Location) (ent.Value, error) {
			return l.Longitude, nil
		},
		column: location.FieldLongitude,
		toTerm: location.ByLongitude,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.Longitude,
			}
		},
	}
	// LocationOrderFieldAddress orders Location by address.
	LocationOrderFieldAddress = &LocationOrderField{
		Value: func(l *Location) (ent.Value, error) {
			return l.Address, nil
		},
		column: location.FieldAddress,
		toTerm: location.ByAddress,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.Address,
			}
		},
	}
	// LocationOrderFieldPostcode orders Location by postcode.
	LocationOrderFieldPostcode = &LocationOrderField{
		Value: func(l *Location) (ent.Value, error) {
			return l.Postcode, nil
		},
		column: location.FieldPostcode,
		toTerm: location.ByPostcode,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.Postcode,
			}
		},
	}
	// LocationOrderFieldType orders Location by type.
	LocationOrderFieldType = &LocationOrderField{
		Value: func(l *Location) (ent.Value, error) {
			return l.Type, nil
		},
		column: location.FieldType,
		toTerm: location.ByType,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.Type,
			}
		},
	}
	// LocationOrderFieldState orders Location by state.
	LocationOrderFieldState = &LocationOrderField{
		Value: func(l *Location) (ent.Value, error) {
			return l.State, nil
		},
		column: location.FieldState,
		toTerm: location.ByState,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.State,
			}
		},
	}
	// LocationOrderFieldSuburb orders Location by suburb.
	LocationOrderFieldSuburb = &LocationOrderField{
		Value: func(l *Location) (ent.Value, error) {
			return l.Suburb, nil
		},
		column: location.FieldSuburb,
		toTerm: location.BySuburb,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.Suburb,
			}
		},
	}
	// LocationOrderFieldStreetType orders Location by street_type.
	LocationOrderFieldStreetType = &LocationOrderField{
		Value: func(l *Location) (ent.Value, error) {
			return l.StreetType, nil
		},
		column: location.FieldStreetType,
		toTerm: location.ByStreetType,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.StreetType,
			}
		},
	}
	// LocationOrderFieldStreetName orders Location by street_name.
	LocationOrderFieldStreetName = &LocationOrderField{
		Value: func(l *Location) (ent.Value, error) {
			return l.StreetName, nil
		},
		column: location.FieldStreetName,
		toTerm: location.ByStreetName,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.StreetName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f LocationOrderField) String() string {
	var str string
	switch f.column {
	case LocationOrderFieldID.column:
		str = "ID"
	case LocationOrderFieldTitle.column:
		str = "TITLE"
	case LocationOrderFieldDescription.column:
		str = "DESCRIPTION"
	case LocationOrderFieldLatitude.column:
		str = "LATITUDE"
	case LocationOrderFieldLongitude.column:
		str = "LONGITUDE"
	case LocationOrderFieldAddress.column:
		str = "ADDRESS"
	case LocationOrderFieldPostcode.column:
		str = "POSTCODE"
	case LocationOrderFieldType.column:
		str = "TYPE"
	case LocationOrderFieldState.column:
		str = "STATE"
	case LocationOrderFieldSuburb.column:
		str = "SUBURB"
	case LocationOrderFieldStreetType.column:
		str = "STREET_TYPE"
	case LocationOrderFieldStreetName.column:
		str = "STREET_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f LocationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *LocationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("LocationOrderField %T must be a string", v)
	}
	switch str {
	case "ID":
		*f = *LocationOrderFieldID
	case "TITLE":
		*f = *LocationOrderFieldTitle
	case "DESCRIPTION":
		*f = *LocationOrderFieldDescription
	case "LATITUDE":
		*f = *LocationOrderFieldLatitude
	case "LONGITUDE":
		*f = *LocationOrderFieldLongitude
	case "ADDRESS":
		*f = *LocationOrderFieldAddress
	case "POSTCODE":
		*f = *LocationOrderFieldPostcode
	case "TYPE":
		*f = *LocationOrderFieldType
	case "STATE":
		*f = *LocationOrderFieldState
	case "SUBURB":
		*f = *LocationOrderFieldSuburb
	case "STREET_TYPE":
		*f = *LocationOrderFieldStreetType
	case "STREET_NAME":
		*f = *LocationOrderFieldStreetName
	default:
		return fmt.Errorf("%s is not a valid LocationOrderField", str)
	}
	return nil
}

// LocationOrderField defines the ordering field of Location.
type LocationOrderField struct {
	// Value extracts the ordering value from the given Location.
	Value    func(*Location) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) location.OrderOption
	toCursor func(*Location) Cursor
}

// LocationOrder defines the ordering of Location.
type LocationOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *LocationOrderField `json:"field"`
}

// DefaultLocationOrder is the default ordering of Location.
var DefaultLocationOrder = &LocationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &LocationOrderField{
		Value: func(l *Location) (ent.Value, error) {
			return l.ID, nil
		},
		column: location.FieldID,
		toTerm: location.ByID,
		toCursor: func(l *Location) Cursor {
			return Cursor{ID: l.ID}
		},
	},
}

// ToEdge converts Location into LocationEdge.
func (l *Location) ToEdge(order *LocationOrder) *LocationEdge {
	if order == nil {
		order = DefaultLocationOrder
	}
	return &LocationEdge{
		Node:   l,
		Cursor: order.Field.toCursor(l),
	}
}

// PhoneEdge is the edge representation of Phone.
type PhoneEdge struct {
	Node   *Phone `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// PhoneConnection is the connection containing edges to Phone.
type PhoneConnection struct {
	Edges      []*PhoneEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *PhoneConnection) build(nodes []*Phone, pager *phonePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Phone
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Phone {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Phone {
			return nodes[i]
		}
	}
	c.Edges = make([]*PhoneEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PhoneEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PhonePaginateOption enables pagination customization.
type PhonePaginateOption func(*phonePager) error

// WithPhoneOrder configures pagination ordering.
func WithPhoneOrder(order *PhoneOrder) PhonePaginateOption {
	if order == nil {
		order = DefaultPhoneOrder
	}
	o := *order
	return func(pager *phonePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPhoneOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPhoneFilter configures pagination filter.
func WithPhoneFilter(filter func(*PhoneQuery) (*PhoneQuery, error)) PhonePaginateOption {
	return func(pager *phonePager) error {
		if filter == nil {
			return errors.New("PhoneQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type phonePager struct {
	reverse bool
	order   *PhoneOrder
	filter  func(*PhoneQuery) (*PhoneQuery, error)
}

func newPhonePager(opts []PhonePaginateOption, reverse bool) (*phonePager, error) {
	pager := &phonePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPhoneOrder
	}
	return pager, nil
}

func (p *phonePager) applyFilter(query *PhoneQuery) (*PhoneQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *phonePager) toCursor(ph *Phone) Cursor {
	return p.order.Field.toCursor(ph)
}

func (p *phonePager) applyCursors(query *PhoneQuery, after, before *Cursor) (*PhoneQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPhoneOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *phonePager) applyOrder(query *PhoneQuery) *PhoneQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPhoneOrder.Field {
		query = query.Order(DefaultPhoneOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *phonePager) orderExpr(query *PhoneQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPhoneOrder.Field {
			b.Comma().Ident(DefaultPhoneOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Phone.
func (ph *PhoneQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PhonePaginateOption,
) (*PhoneConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPhonePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ph, err = pager.applyFilter(ph); err != nil {
		return nil, err
	}
	conn := &PhoneConnection{Edges: []*PhoneEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ph.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if ph, err = pager.applyCursors(ph, after, before); err != nil {
		return nil, err
	}
	ph = pager.applyOrder(ph)
	if limit := paginateLimit(first, last); limit != 0 {
		ph.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ph.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := ph.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PhoneOrderFieldID orders Phone by id.
	PhoneOrderFieldID = &PhoneOrderField{
		Value: func(ph *Phone) (ent.Value, error) {
			return ph.ID, nil
		},
		column: phone.FieldID,
		toTerm: phone.ByID,
		toCursor: func(ph *Phone) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.ID,
			}
		},
	}
	// PhoneOrderFieldTitle orders Phone by title.
	PhoneOrderFieldTitle = &PhoneOrderField{
		Value: func(ph *Phone) (ent.Value, error) {
			return ph.Title, nil
		},
		column: phone.FieldTitle,
		toTerm: phone.ByTitle,
		toCursor: func(ph *Phone) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.Title,
			}
		},
	}
	// PhoneOrderFieldDescription orders Phone by description.
	PhoneOrderFieldDescription = &PhoneOrderField{
		Value: func(ph *Phone) (ent.Value, error) {
			return ph.Description, nil
		},
		column: phone.FieldDescription,
		toTerm: phone.ByDescription,
		toCursor: func(ph *Phone) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.Description,
			}
		},
	}
	// PhoneOrderFieldNumber orders Phone by number.
	PhoneOrderFieldNumber = &PhoneOrderField{
		Value: func(ph *Phone) (ent.Value, error) {
			return ph.Number, nil
		},
		column: phone.FieldNumber,
		toTerm: phone.ByNumber,
		toCursor: func(ph *Phone) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.Number,
			}
		},
	}
	// PhoneOrderFieldType orders Phone by type.
	PhoneOrderFieldType = &PhoneOrderField{
		Value: func(ph *Phone) (ent.Value, error) {
			return ph.Type, nil
		},
		column: phone.FieldType,
		toTerm: phone.ByType,
		toCursor: func(ph *Phone) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.Type,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PhoneOrderField) String() string {
	var str string
	switch f.column {
	case PhoneOrderFieldID.column:
		str = "ID"
	case PhoneOrderFieldTitle.column:
		str = "TITLE"
	case PhoneOrderFieldDescription.column:
		str = "DESCRIPTION"
	case PhoneOrderFieldNumber.column:
		str = "NUMBER"
	case PhoneOrderFieldType.column:
		str = "TYPE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PhoneOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PhoneOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PhoneOrderField %T must be a string", v)
	}
	switch str {
	case "ID":
		*f = *PhoneOrderFieldID
	case "TITLE":
		*f = *PhoneOrderFieldTitle
	case "DESCRIPTION":
		*f = *PhoneOrderFieldDescription
	case "NUMBER":
		*f = *PhoneOrderFieldNumber
	case "TYPE":
		*f = *PhoneOrderFieldType
	default:
		return fmt.Errorf("%s is not a valid PhoneOrderField", str)
	}
	return nil
}

// PhoneOrderField defines the ordering field of Phone.
type PhoneOrderField struct {
	// Value extracts the ordering value from the given Phone.
	Value    func(*Phone) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) phone.OrderOption
	toCursor func(*Phone) Cursor
}

// PhoneOrder defines the ordering of Phone.
type PhoneOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *PhoneOrderField `json:"field"`
}

// DefaultPhoneOrder is the default ordering of Phone.
var DefaultPhoneOrder = &PhoneOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PhoneOrderField{
		Value: func(ph *Phone) (ent.Value, error) {
			return ph.ID, nil
		},
		column: phone.FieldID,
		toTerm: phone.ByID,
		toCursor: func(ph *Phone) Cursor {
			return Cursor{ID: ph.ID}
		},
	},
}

// ToEdge converts Phone into PhoneEdge.
func (ph *Phone) ToEdge(order *PhoneOrder) *PhoneEdge {
	if order == nil {
		order = DefaultPhoneOrder
	}
	return &PhoneEdge{
		Node:   ph,
		Cursor: order.Field.toCursor(ph),
	}
}

// ProductEdge is the edge representation of Product.
type ProductEdge struct {
	Node   *Product `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProductConnection is the connection containing edges to Product.
type ProductConnection struct {
	Edges      []*ProductEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ProductConnection) build(nodes []*Product, pager *productPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Product
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Product {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Product {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProductEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProductEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProductPaginateOption enables pagination customization.
type ProductPaginateOption func(*productPager) error

// WithProductOrder configures pagination ordering.
func WithProductOrder(order *ProductOrder) ProductPaginateOption {
	if order == nil {
		order = DefaultProductOrder
	}
	o := *order
	return func(pager *productPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProductOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProductFilter configures pagination filter.
func WithProductFilter(filter func(*ProductQuery) (*ProductQuery, error)) ProductPaginateOption {
	return func(pager *productPager) error {
		if filter == nil {
			return errors.New("ProductQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type productPager struct {
	reverse bool
	order   *ProductOrder
	filter  func(*ProductQuery) (*ProductQuery, error)
}

func newProductPager(opts []ProductPaginateOption, reverse bool) (*productPager, error) {
	pager := &productPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProductOrder
	}
	return pager, nil
}

func (p *productPager) applyFilter(query *ProductQuery) (*ProductQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *productPager) toCursor(pr *Product) Cursor {
	return p.order.Field.toCursor(pr)
}

func (p *productPager) applyCursors(query *ProductQuery, after, before *Cursor) (*ProductQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProductOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *productPager) applyOrder(query *ProductQuery) *ProductQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProductOrder.Field {
		query = query.Order(DefaultProductOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *productPager) orderExpr(query *ProductQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProductOrder.Field {
			b.Comma().Ident(DefaultProductOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Product.
func (pr *ProductQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProductPaginateOption,
) (*ProductConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProductPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}
	conn := &ProductConnection{Edges: []*ProductEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pr.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if pr, err = pager.applyCursors(pr, after, before); err != nil {
		return nil, err
	}
	pr = pager.applyOrder(pr)
	if limit := paginateLimit(first, last); limit != 0 {
		pr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pr.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := pr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProductOrderFieldID orders Product by id.
	ProductOrderFieldID = &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.ID, nil
		},
		column: product.FieldID,
		toTerm: product.ByID,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.ID,
			}
		},
	}
	// ProductOrderFieldName orders Product by name.
	ProductOrderFieldName = &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.Name, nil
		},
		column: product.FieldName,
		toTerm: product.ByName,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.Name,
			}
		},
	}
	// ProductOrderFieldDescription orders Product by description.
	ProductOrderFieldDescription = &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.Description, nil
		},
		column: product.FieldDescription,
		toTerm: product.ByDescription,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.Description,
			}
		},
	}
	// ProductOrderFieldImage orders Product by image.
	ProductOrderFieldImage = &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.Image, nil
		},
		column: product.FieldImage,
		toTerm: product.ByImage,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.Image,
			}
		},
	}
	// ProductOrderFieldURL orders Product by url.
	ProductOrderFieldURL = &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.URL, nil
		},
		column: product.FieldURL,
		toTerm: product.ByURL,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.URL,
			}
		},
	}
	// ProductOrderFieldLastSell orders Product by last_sell.
	ProductOrderFieldLastSell = &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.LastSell, nil
		},
		column: product.FieldLastSell,
		toTerm: product.ByLastSell,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.LastSell,
			}
		},
	}
	// ProductOrderFieldCreatedAt orders Product by created_at.
	ProductOrderFieldCreatedAt = &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.CreatedAt, nil
		},
		column: product.FieldCreatedAt,
		toTerm: product.ByCreatedAt,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.CreatedAt,
			}
		},
	}
	// ProductOrderFieldStatus orders Product by status.
	ProductOrderFieldStatus = &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.Status, nil
		},
		column: product.FieldStatus,
		toTerm: product.ByStatus,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.Status,
			}
		},
	}
	// ProductOrderFieldBuildStatus orders Product by build_status.
	ProductOrderFieldBuildStatus = &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.BuildStatus, nil
		},
		column: product.FieldBuildStatus,
		toTerm: product.ByBuildStatus,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.BuildStatus,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProductOrderField) String() string {
	var str string
	switch f.column {
	case ProductOrderFieldID.column:
		str = "ID"
	case ProductOrderFieldName.column:
		str = "TITLE"
	case ProductOrderFieldDescription.column:
		str = "DESCRIPTION"
	case ProductOrderFieldImage.column:
		str = "IMAGE"
	case ProductOrderFieldURL.column:
		str = "URL"
	case ProductOrderFieldLastSell.column:
		str = "LAST_SELL"
	case ProductOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ProductOrderFieldStatus.column:
		str = "STATUS"
	case ProductOrderFieldBuildStatus.column:
		str = "BUILD_STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProductOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProductOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProductOrderField %T must be a string", v)
	}
	switch str {
	case "ID":
		*f = *ProductOrderFieldID
	case "TITLE":
		*f = *ProductOrderFieldName
	case "DESCRIPTION":
		*f = *ProductOrderFieldDescription
	case "IMAGE":
		*f = *ProductOrderFieldImage
	case "URL":
		*f = *ProductOrderFieldURL
	case "LAST_SELL":
		*f = *ProductOrderFieldLastSell
	case "CREATED_AT":
		*f = *ProductOrderFieldCreatedAt
	case "STATUS":
		*f = *ProductOrderFieldStatus
	case "BUILD_STATUS":
		*f = *ProductOrderFieldBuildStatus
	default:
		return fmt.Errorf("%s is not a valid ProductOrderField", str)
	}
	return nil
}

// ProductOrderField defines the ordering field of Product.
type ProductOrderField struct {
	// Value extracts the ordering value from the given Product.
	Value    func(*Product) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) product.OrderOption
	toCursor func(*Product) Cursor
}

// ProductOrder defines the ordering of Product.
type ProductOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProductOrderField `json:"field"`
}

// DefaultProductOrder is the default ordering of Product.
var DefaultProductOrder = &ProductOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.ID, nil
		},
		column: product.FieldID,
		toTerm: product.ByID,
		toCursor: func(pr *Product) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Product into ProductEdge.
func (pr *Product) ToEdge(order *ProductOrder) *ProductEdge {
	if order == nil {
		order = DefaultProductOrder
	}
	return &ProductEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// VendorEdge is the edge representation of Vendor.
type VendorEdge struct {
	Node   *Vendor `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// VendorConnection is the connection containing edges to Vendor.
type VendorConnection struct {
	Edges      []*VendorEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *VendorConnection) build(nodes []*Vendor, pager *vendorPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Vendor
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Vendor {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Vendor {
			return nodes[i]
		}
	}
	c.Edges = make([]*VendorEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &VendorEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// VendorPaginateOption enables pagination customization.
type VendorPaginateOption func(*vendorPager) error

// WithVendorOrder configures pagination ordering.
func WithVendorOrder(order *VendorOrder) VendorPaginateOption {
	if order == nil {
		order = DefaultVendorOrder
	}
	o := *order
	return func(pager *vendorPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultVendorOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithVendorFilter configures pagination filter.
func WithVendorFilter(filter func(*VendorQuery) (*VendorQuery, error)) VendorPaginateOption {
	return func(pager *vendorPager) error {
		if filter == nil {
			return errors.New("VendorQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type vendorPager struct {
	reverse bool
	order   *VendorOrder
	filter  func(*VendorQuery) (*VendorQuery, error)
}

func newVendorPager(opts []VendorPaginateOption, reverse bool) (*vendorPager, error) {
	pager := &vendorPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultVendorOrder
	}
	return pager, nil
}

func (p *vendorPager) applyFilter(query *VendorQuery) (*VendorQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *vendorPager) toCursor(v *Vendor) Cursor {
	return p.order.Field.toCursor(v)
}

func (p *vendorPager) applyCursors(query *VendorQuery, after, before *Cursor) (*VendorQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultVendorOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *vendorPager) applyOrder(query *VendorQuery) *VendorQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultVendorOrder.Field {
		query = query.Order(DefaultVendorOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *vendorPager) orderExpr(query *VendorQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultVendorOrder.Field {
			b.Comma().Ident(DefaultVendorOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Vendor.
func (v *VendorQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...VendorPaginateOption,
) (*VendorConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newVendorPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if v, err = pager.applyFilter(v); err != nil {
		return nil, err
	}
	conn := &VendorConnection{Edges: []*VendorEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = v.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if v, err = pager.applyCursors(v, after, before); err != nil {
		return nil, err
	}
	v = pager.applyOrder(v)
	if limit := paginateLimit(first, last); limit != 0 {
		v.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := v.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := v.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// VendorOrderFieldID orders Vendor by id.
	VendorOrderFieldID = &VendorOrderField{
		Value: func(v *Vendor) (ent.Value, error) {
			return v.ID, nil
		},
		column: vendor.FieldID,
		toTerm: vendor.ByID,
		toCursor: func(v *Vendor) Cursor {
			return Cursor{
				ID:    v.ID,
				Value: v.ID,
			}
		},
	}
	// VendorOrderFieldName orders Vendor by name.
	VendorOrderFieldName = &VendorOrderField{
		Value: func(v *Vendor) (ent.Value, error) {
			return v.Name, nil
		},
		column: vendor.FieldName,
		toTerm: vendor.ByName,
		toCursor: func(v *Vendor) Cursor {
			return Cursor{
				ID:    v.ID,
				Value: v.Name,
			}
		},
	}
	// VendorOrderFieldSchema orders Vendor by schema.
	VendorOrderFieldSchema = &VendorOrderField{
		Value: func(v *Vendor) (ent.Value, error) {
			return v.Schema, nil
		},
		column: vendor.FieldSchema,
		toTerm: vendor.BySchema,
		toCursor: func(v *Vendor) Cursor {
			return Cursor{
				ID:    v.ID,
				Value: v.Schema,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f VendorOrderField) String() string {
	var str string
	switch f.column {
	case VendorOrderFieldID.column:
		str = "ID"
	case VendorOrderFieldName.column:
		str = "NAME"
	case VendorOrderFieldSchema.column:
		str = "SCHEMA"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f VendorOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *VendorOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("VendorOrderField %T must be a string", v)
	}
	switch str {
	case "ID":
		*f = *VendorOrderFieldID
	case "NAME":
		*f = *VendorOrderFieldName
	case "SCHEMA":
		*f = *VendorOrderFieldSchema
	default:
		return fmt.Errorf("%s is not a valid VendorOrderField", str)
	}
	return nil
}

// VendorOrderField defines the ordering field of Vendor.
type VendorOrderField struct {
	// Value extracts the ordering value from the given Vendor.
	Value    func(*Vendor) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) vendor.OrderOption
	toCursor func(*Vendor) Cursor
}

// VendorOrder defines the ordering of Vendor.
type VendorOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *VendorOrderField `json:"field"`
}

// DefaultVendorOrder is the default ordering of Vendor.
var DefaultVendorOrder = &VendorOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &VendorOrderField{
		Value: func(v *Vendor) (ent.Value, error) {
			return v.ID, nil
		},
		column: vendor.FieldID,
		toTerm: vendor.ByID,
		toCursor: func(v *Vendor) Cursor {
			return Cursor{ID: v.ID}
		},
	},
}

// ToEdge converts Vendor into VendorEdge.
func (v *Vendor) ToEdge(order *VendorOrder) *VendorEdge {
	if order == nil {
		order = DefaultVendorOrder
	}
	return &VendorEdge{
		Node:   v,
		Cursor: order.Field.toCursor(v),
	}
}

// WarehouseEdge is the edge representation of Warehouse.
type WarehouseEdge struct {
	Node   *Warehouse `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// WarehouseConnection is the connection containing edges to Warehouse.
type WarehouseConnection struct {
	Edges      []*WarehouseEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *WarehouseConnection) build(nodes []*Warehouse, pager *warehousePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Warehouse
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Warehouse {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Warehouse {
			return nodes[i]
		}
	}
	c.Edges = make([]*WarehouseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WarehouseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WarehousePaginateOption enables pagination customization.
type WarehousePaginateOption func(*warehousePager) error

// WithWarehouseOrder configures pagination ordering.
func WithWarehouseOrder(order *WarehouseOrder) WarehousePaginateOption {
	if order == nil {
		order = DefaultWarehouseOrder
	}
	o := *order
	return func(pager *warehousePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWarehouseOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWarehouseFilter configures pagination filter.
func WithWarehouseFilter(filter func(*WarehouseQuery) (*WarehouseQuery, error)) WarehousePaginateOption {
	return func(pager *warehousePager) error {
		if filter == nil {
			return errors.New("WarehouseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type warehousePager struct {
	reverse bool
	order   *WarehouseOrder
	filter  func(*WarehouseQuery) (*WarehouseQuery, error)
}

func newWarehousePager(opts []WarehousePaginateOption, reverse bool) (*warehousePager, error) {
	pager := &warehousePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWarehouseOrder
	}
	return pager, nil
}

func (p *warehousePager) applyFilter(query *WarehouseQuery) (*WarehouseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *warehousePager) toCursor(w *Warehouse) Cursor {
	return p.order.Field.toCursor(w)
}

func (p *warehousePager) applyCursors(query *WarehouseQuery, after, before *Cursor) (*WarehouseQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWarehouseOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *warehousePager) applyOrder(query *WarehouseQuery) *WarehouseQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWarehouseOrder.Field {
		query = query.Order(DefaultWarehouseOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *warehousePager) orderExpr(query *WarehouseQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWarehouseOrder.Field {
			b.Comma().Ident(DefaultWarehouseOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Warehouse.
func (w *WarehouseQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WarehousePaginateOption,
) (*WarehouseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWarehousePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if w, err = pager.applyFilter(w); err != nil {
		return nil, err
	}
	conn := &WarehouseConnection{Edges: []*WarehouseEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = w.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if w, err = pager.applyCursors(w, after, before); err != nil {
		return nil, err
	}
	w = pager.applyOrder(w)
	if limit := paginateLimit(first, last); limit != 0 {
		w.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := w.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := w.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WarehouseOrderFieldID orders Warehouse by id.
	WarehouseOrderFieldID = &WarehouseOrderField{
		Value: func(w *Warehouse) (ent.Value, error) {
			return w.ID, nil
		},
		column: warehouse.FieldID,
		toTerm: warehouse.ByID,
		toCursor: func(w *Warehouse) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.ID,
			}
		},
	}
	// WarehouseOrderFieldName orders Warehouse by name.
	WarehouseOrderFieldName = &WarehouseOrderField{
		Value: func(w *Warehouse) (ent.Value, error) {
			return w.Name, nil
		},
		column: warehouse.FieldName,
		toTerm: warehouse.ByName,
		toCursor: func(w *Warehouse) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.Name,
			}
		},
	}
	// WarehouseOrderFieldLastUpdate orders Warehouse by last_update.
	WarehouseOrderFieldLastUpdate = &WarehouseOrderField{
		Value: func(w *Warehouse) (ent.Value, error) {
			return w.LastUpdate, nil
		},
		column: warehouse.FieldLastUpdate,
		toTerm: warehouse.ByLastUpdate,
		toCursor: func(w *Warehouse) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.LastUpdate,
			}
		},
	}
	// WarehouseOrderFieldEnabled orders Warehouse by enabled.
	WarehouseOrderFieldEnabled = &WarehouseOrderField{
		Value: func(w *Warehouse) (ent.Value, error) {
			return w.Enabled, nil
		},
		column: warehouse.FieldEnabled,
		toTerm: warehouse.ByEnabled,
		toCursor: func(w *Warehouse) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.Enabled,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WarehouseOrderField) String() string {
	var str string
	switch f.column {
	case WarehouseOrderFieldID.column:
		str = "ID"
	case WarehouseOrderFieldName.column:
		str = "NAME"
	case WarehouseOrderFieldLastUpdate.column:
		str = "LAST_UPDATE"
	case WarehouseOrderFieldEnabled.column:
		str = "ENABLED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WarehouseOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WarehouseOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WarehouseOrderField %T must be a string", v)
	}
	switch str {
	case "ID":
		*f = *WarehouseOrderFieldID
	case "NAME":
		*f = *WarehouseOrderFieldName
	case "LAST_UPDATE":
		*f = *WarehouseOrderFieldLastUpdate
	case "ENABLED":
		*f = *WarehouseOrderFieldEnabled
	default:
		return fmt.Errorf("%s is not a valid WarehouseOrderField", str)
	}
	return nil
}

// WarehouseOrderField defines the ordering field of Warehouse.
type WarehouseOrderField struct {
	// Value extracts the ordering value from the given Warehouse.
	Value    func(*Warehouse) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) warehouse.OrderOption
	toCursor func(*Warehouse) Cursor
}

// WarehouseOrder defines the ordering of Warehouse.
type WarehouseOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *WarehouseOrderField `json:"field"`
}

// DefaultWarehouseOrder is the default ordering of Warehouse.
var DefaultWarehouseOrder = &WarehouseOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WarehouseOrderField{
		Value: func(w *Warehouse) (ent.Value, error) {
			return w.ID, nil
		},
		column: warehouse.FieldID,
		toTerm: warehouse.ByID,
		toCursor: func(w *Warehouse) Cursor {
			return Cursor{ID: w.ID}
		},
	},
}

// ToEdge converts Warehouse into WarehouseEdge.
func (w *Warehouse) ToEdge(order *WarehouseOrder) *WarehouseEdge {
	if order == nil {
		order = DefaultWarehouseOrder
	}
	return &WarehouseEdge{
		Node:   w,
		Cursor: order.Field.toCursor(w),
	}
}

// WebsiteEdge is the edge representation of Website.
type WebsiteEdge struct {
	Node   *Website `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// WebsiteConnection is the connection containing edges to Website.
type WebsiteConnection struct {
	Edges      []*WebsiteEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *WebsiteConnection) build(nodes []*Website, pager *websitePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Website
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Website {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Website {
			return nodes[i]
		}
	}
	c.Edges = make([]*WebsiteEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WebsiteEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WebsitePaginateOption enables pagination customization.
type WebsitePaginateOption func(*websitePager) error

// WithWebsiteOrder configures pagination ordering.
func WithWebsiteOrder(order *WebsiteOrder) WebsitePaginateOption {
	if order == nil {
		order = DefaultWebsiteOrder
	}
	o := *order
	return func(pager *websitePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWebsiteOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWebsiteFilter configures pagination filter.
func WithWebsiteFilter(filter func(*WebsiteQuery) (*WebsiteQuery, error)) WebsitePaginateOption {
	return func(pager *websitePager) error {
		if filter == nil {
			return errors.New("WebsiteQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type websitePager struct {
	reverse bool
	order   *WebsiteOrder
	filter  func(*WebsiteQuery) (*WebsiteQuery, error)
}

func newWebsitePager(opts []WebsitePaginateOption, reverse bool) (*websitePager, error) {
	pager := &websitePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWebsiteOrder
	}
	return pager, nil
}

func (p *websitePager) applyFilter(query *WebsiteQuery) (*WebsiteQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *websitePager) toCursor(w *Website) Cursor {
	return p.order.Field.toCursor(w)
}

func (p *websitePager) applyCursors(query *WebsiteQuery, after, before *Cursor) (*WebsiteQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWebsiteOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *websitePager) applyOrder(query *WebsiteQuery) *WebsiteQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWebsiteOrder.Field {
		query = query.Order(DefaultWebsiteOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *websitePager) orderExpr(query *WebsiteQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWebsiteOrder.Field {
			b.Comma().Ident(DefaultWebsiteOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Website.
func (w *WebsiteQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WebsitePaginateOption,
) (*WebsiteConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWebsitePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if w, err = pager.applyFilter(w); err != nil {
		return nil, err
	}
	conn := &WebsiteConnection{Edges: []*WebsiteEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = w.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if w, err = pager.applyCursors(w, after, before); err != nil {
		return nil, err
	}
	w = pager.applyOrder(w)
	if limit := paginateLimit(first, last); limit != 0 {
		w.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := w.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := w.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WebsiteOrderFieldID orders Website by id.
	WebsiteOrderFieldID = &WebsiteOrderField{
		Value: func(w *Website) (ent.Value, error) {
			return w.ID, nil
		},
		column: website.FieldID,
		toTerm: website.ByID,
		toCursor: func(w *Website) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.ID,
			}
		},
	}
	// WebsiteOrderFieldTitle orders Website by title.
	WebsiteOrderFieldTitle = &WebsiteOrderField{
		Value: func(w *Website) (ent.Value, error) {
			return w.Title, nil
		},
		column: website.FieldTitle,
		toTerm: website.ByTitle,
		toCursor: func(w *Website) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.Title,
			}
		},
	}
	// WebsiteOrderFieldDescription orders Website by description.
	WebsiteOrderFieldDescription = &WebsiteOrderField{
		Value: func(w *Website) (ent.Value, error) {
			return w.Description, nil
		},
		column: website.FieldDescription,
		toTerm: website.ByDescription,
		toCursor: func(w *Website) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.Description,
			}
		},
	}
	// WebsiteOrderFieldURL orders Website by url.
	WebsiteOrderFieldURL = &WebsiteOrderField{
		Value: func(w *Website) (ent.Value, error) {
			return w.URL, nil
		},
		column: website.FieldURL,
		toTerm: website.ByURL,
		toCursor: func(w *Website) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.URL,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WebsiteOrderField) String() string {
	var str string
	switch f.column {
	case WebsiteOrderFieldID.column:
		str = "ID"
	case WebsiteOrderFieldTitle.column:
		str = "TITLE"
	case WebsiteOrderFieldDescription.column:
		str = "DESCRIPTION"
	case WebsiteOrderFieldURL.column:
		str = "URL"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WebsiteOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WebsiteOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WebsiteOrderField %T must be a string", v)
	}
	switch str {
	case "ID":
		*f = *WebsiteOrderFieldID
	case "TITLE":
		*f = *WebsiteOrderFieldTitle
	case "DESCRIPTION":
		*f = *WebsiteOrderFieldDescription
	case "URL":
		*f = *WebsiteOrderFieldURL
	default:
		return fmt.Errorf("%s is not a valid WebsiteOrderField", str)
	}
	return nil
}

// WebsiteOrderField defines the ordering field of Website.
type WebsiteOrderField struct {
	// Value extracts the ordering value from the given Website.
	Value    func(*Website) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) website.OrderOption
	toCursor func(*Website) Cursor
}

// WebsiteOrder defines the ordering of Website.
type WebsiteOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *WebsiteOrderField `json:"field"`
}

// DefaultWebsiteOrder is the default ordering of Website.
var DefaultWebsiteOrder = &WebsiteOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WebsiteOrderField{
		Value: func(w *Website) (ent.Value, error) {
			return w.ID, nil
		},
		column: website.FieldID,
		toTerm: website.ByID,
		toCursor: func(w *Website) Cursor {
			return Cursor{ID: w.ID}
		},
	},
}

// ToEdge converts Website into WebsiteEdge.
func (w *Website) ToEdge(order *WebsiteOrder) *WebsiteEdge {
	if order == nil {
		order = DefaultWebsiteOrder
	}
	return &WebsiteEdge{
		Node:   w,
		Cursor: order.Field.toCursor(w),
	}
}
